<!--
// Объект Vue, через переменную app можно в JS-коде получать доступ данным и методам этого Vue-объекта
var app = new Vue({
    // id или класс DOM-ноды, связанной с этим Vue-объектом
    el: '#app',
    // Данные, которые используются этим Vue-объектом (можно использовать в связанной DOM-ноде)
    data: {
        counter: 0
    },
    // Методы, которые этим Vue-объектом (можно вызывать в связанной DOM-ноде)
    methods: {
        add: function() {
            this.counter++;
        }
    },
    // Предвычисленные методы, вызываются только при изменении использованных данных, в DOM-ноде вызываются как переменные, а не как функции
    computed {
        add2: function() {
            return this.counter + 10;
        }
    },
    // Функции слежения, вызываются при любом изменении одноименной переменной
    watch:
        counter: function(value) {
            console.log("Значение counter изменилось на ", value)
        },
    // Дополнительный HTML, который при инициализации встроится базовый HTML, обязательно должен быть обёрнут в <div>
    template: '<div><h1>{{ counter }}</h1></div>',

    --=== Переопределяемые функции жизненного цикла ===--

    // Вызовется всегда после инициализации, но до создания
    beforeCreate: function() {},
    // Вызовется сразу после создания
    created: function() {},
    // Вызовется перед привязкой к DOM-объекту
    beforeMount: function() {},
    // Вызовется после привязки к DOM-объекту
    mounted: function() {},
    // Вызовется перед обновлением
    beforeUpdate: function() {},
    // Вызовется после обновления
    updated: function() {},
    // Вызовется перед удалением Vue-объекта (this.$destroy() - функция самоуничтожения)
    beforeDestroy: function() {},
    // Вызовется после уничтожения Vue-объекта
    destroyed: function() {},
})


app.$mount('#app2') - добавление существующего Vue-обекта к другому DOM-элементу (со старого #app Vue-объект пропадёт!!!)
-->

<a v-bind:href="url">Link</a> <!--значение в динамические параметры-->
<a :href="url">Link</a> <!--короткая форма динамического параметра-->

<div v-html="link"></div> <!--вывод заранее приготовленного куска html-->
<button v-on:click="onClick"></button> <!--события-->
<button @click="onClick"></button> <!--короткая форма определения  события-->
<button v-on:click="onClick(5, 10)"></button> <!--вызов функции события с параметрами-->
<button v-on:click.prevent="onClick"></button> <!--Установка модификатора события, в данном случае preventDefault()-->

<input type="text" v-model="inputValue"> <!--2 way binding - двустороннее связывание между инпутом и другим элементом -->
<h2>{{ inputValue }}</h2>               <!--(между моделью в коде и представлением на странице)-->

<div class="block" :class="{'red': isActive, 'green': !isActive}" :class="blue"></div> <!--Добавление классов в ноду:
red, green - названия классов, isActive - булево выражение, по которому определяется наличие класса у ноды
blue - безусловное добавление класса-->
<div class="block" :class="[blue, {'red': isActive}], getCSSClasses()"></div> <!--комбинация из разных способов добавления-->

<h1 v-if="isVisible">Если isVisible == true</h1> <!--Простой if, работает на отображение элемента-->
<h1 v-else>Если isVisible == false</h1> <!--Первый else после if считается относящимся к этому if. При множественных if используем директиву v-else-if-->

<h1 v-show="isVisible">Если isVisible == true</h1> <!--Аналогично v-if, но не удаляет элементы из DOM, только скрывает-->

<ul><li v-for="(item, index) in array">{{ item }}</li></ul> <!--Вывод массива array, на каждой итерации текущий элемент массива лежит в item, индекс - в index-->
<ul><li v-for="(key, value, index) in object">{{ key }}: {{ value }}</li></ul> <!--Вывод полей ключ: значение объекта object-->

<h1 ref="heading"></h1> <!--Создаём связывание этого конкретного DOM-объекта с названием "heading"-->
<!--this.$refs.heading.style.color = 'red' - через специальный массив $refs можем в коде получить доступ к связанному элементу-->




settings.json
{
    "go.useCodeSnippetsOnFunctionSuggest": false,
    "go.autocompleteUnimportedPackages": true,
    "go.installDependenciesWhenBuilding": true,
    "explorer.confirmDragAndDrop": false,
    "go.buildOnSave": "package",
    "go.lintOnSave": "package",
    "go.vetOnSave": "package",
    "go.buildFlags": [],
    "go.lintFlags": [
        "--exclude=\"\bexported \\w+ (\\S*['.]*)([a-zA-Z'.*]*) should have comment or be unexported\b\""
        ],
    "go.vetFlags": [],
    "go.formatTool": "goimports"
}